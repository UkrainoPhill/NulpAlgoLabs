unsorted_part - Лабораторна 1 Варіант 2 Рівень 3
        Напишіть функцію, яка приймає невпорядкований масив цілих чисел і повертає діапазон індексів (початковий і кінцевий) найменшого підмасиву, який потрібно відсортувати для досягнення повного впорядкування всього       масиву.

        Наприклад, для вхідного масиву 1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19

        Результат: (3, 9)

        Підмасив, який потрібно відсортувати для впорядкування всього масиву, починається з індексу 3 (значення 7) і закінчується на індексі 9 (значення 7). У випадку, якщо вхідний масив відсортований, слд повернути кортеж      (-1, -1)

        Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити сценарії коли: вхідний масив посортований, вхідний масив необхідно сортувати весь, масив містить лише 1       елемент.

note_on_board - Лабораторна 2 Варіант 2 Рівень 3
        Пiсля швидкого випуску нової версiї своєї операцiйної системи, компанiя NanoSoft почала отримувати вiд користувачiв численнi повiдомлення про помилки. Щоб слiдкувати за прогресом виправлення помилок, команда розробникiв вирiшила поставити велику квадратну дошку, i прикрiпити до неї по листку для кожної помилки. Проте, щоб дошка вмiстилася в кiмнатi, потрiбно, щоб вона була не надто великою. Всi N листкiв мають прямокутну форму i однаковий розмiр W × H. Їх не можна повертати, а також накладати один на iнший. Знайдiть мiнiмальний розмiр квадратної дошки, яка здатна вмiстити всi листки. Приклад мiнiмальної дошки, яка може вмiстити 10 листкiв 2 × 3 (див картинку)
        
        Вхiднi данi три числа N, W, H — кiлькiсть листкiв, ширина та висота листка вiдповiдно. • 1 ≤ N ≤ 1012 • 1 ≤ W ≤ 109 • 1 ≤ H ≤ 109 Вихiднi данi одне число — мiнiмальна довжина сторони квадратної дошки.
        
        Приклад 1 N, W, H = 10, 2, 3 Результат: 9
        
        Приклад 2 N, W, H = 2, 1000000000, 999999999 Результат: 1999999998
        
        Приклад 3 N, W, H = 4, 1, 1 Результат: 2

balanced_tree - Лабораторна 3 Варіант 2 Рівень 3
        Для заданого бінарного дерева перевірте, чи воно є збалансованим деревом. Бінарне дерево вважається збалансованим, якщо різниця у висоті його лівого та правого піддерев не перевищує 1 для будь-якого піддерева.

        Розглянемо таке бінарне дерево:
        
            1
           / \
          2   3
         / \     
        4   5   
        Це дерево є збалансованим, оскільки різниця висоти лівого піддерева та правого піддерева не перевищує 1.
        
        Реалізована вами функція is_tree_balanced(node: BinaryTree) -> bool отримує на вхід корінь бінарного дерева та повертає True, якщо бінарне дерево є збалансованим, та False, якщо воно не збалансоване.
        
        Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:
        
        class BinaryTree:
            def __init__(self, value, left=None, right=None):
                self.value = value
                self.left = left
                self.right = right
        Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:
        
        root = BinaryTree(3)
        root.left = BinaryTree(9)
        root.right = BinaryTree(20)
binary_tree_priority_queue - Лабораторна 4 Варіант 2 Рівень 2
        Реалізуйте структуру даних "черга з пріоритетами" на основі бінарного дерева binary tree, в якому батьківський елемент має вищий пріоритет, ніж елемент справа, або нижчий або рівний пріоритет, ніж пріоритет його лівої дитини.
        
        Операції, які підтримує ваша черга:
        
        Вставка елемента з заданим значенням та пріоритетом до черги.
        Видалення та повернення елемента з найвищим пріоритетом з черги.
        Перегляд черги без її зміни.
        Для реалізації такої черги з пріоритетами слід використати окремий клас Node, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету.
        Назва файлу реалізації - binary_tree_priority_queue.py
find_the_shortest_safe_route_in_sensor_field - Лабораторна 5 Варіант 4 Рівень 3
        Знайдіть найкоротший безпечний маршрут у полі з датчиками

        Нехай у вас задане прямокутне поле, на якому встановлені датчики в певних місцях. Перетніть його найкоротшим безпечним шляхом, не активуючи датчики.

        Прямокутне поле має форму матриці M × N, і нам потрібно знайти найкоротший шлях від будь-якої клітинки в першому стовпці до будь-якої клітинки в останньому стовпці матриці. Датчики позначаються в матриці значенням   0, і всі її вісім суміжних осередків також можуть активувати датчики. Шлях можна побудувати лише з комірок зі значенням 1, і в будь-який момент ми можемо рухатися лише на один крок в одному з чотирьох напрямків.       Допустимі ходи:

        Вгору: (x, y) -> (x – 1, y)
        Ліворуч: (x, y) -> (x, y – 1)
        Перейти вниз: (x, y) -> (x + 1, y)
        Праворуч: (x, y) -> (x, y + 1)
        Наприклад, розглянемо таку матрицю:

        Найкоротший безпечний шлях має довжину 11. Безпечний маршрут позначений зеленим кольором:

        Для представлення графу слід використати матрицю, який зчитується з файлу input.txt
        Алгоритм має вивести довжину найкоротшого шляху, або -1 якщо такого не існує
beers - Лабораторна 6 Варіант 2 Рівень 3
        Аутсорс компанія (один з лідерів ринку) готується до корпоративу.  HR відділ відправив опитувальник щодо видів пива, які можна буде роздавати на на святі.  Переважно працівники компанії люблять небагато видів пива, і будуть дуже ображені, якщо принаймні одного з пив, які вони люблять, не буде на вечірці.  Оскільки ви - лідер ринку, то вам не можна ображати працівників.
        З іншої сторони, закупити усі можливі види пива - дорого.  Вашим завдання буде з’ясувати скільки різних видів пива потрібно буде привезти на корпоратив.


        Вхідні дані:
	      Перший рядок містить числа N - кількість працівників та B - кількість доступних пив.  Другий рядок містить N*B літер N або Y.  Якщо літера i*N + j - Y, то працівнику i подобається пиво j

        Вихідні дані:
	      Найменша кількість видів пива, яка повинна бути на святі

        Обмеження:
	      Кожному працівнику подобається принаймні один вид пива
	      0 < N < 50
	      0 <B < 50
        Приклади:
        In:
        2 2
        YN NY
        Out:
	      2
	      (Першому працівнику подобається тільки пиво 1, а другому тільки пиво 2, тому доведеться купляти два типи пива)

        In:
        6 3
        YNN YNY YNY NYY NYY NYN
        Out:
	      2
	      (Хоча більшості - чотирьом працівникам - подобається третє пиво, найоптимальніше буде купити 1 та 2 сорти)
kmp - Лабораторна 7 Варіант 2 Рівень 3
        Створити функцію на мові програмування Python, яка приймає дві стрічки: "haystack" (довільний текст) та "needle" (шукана стрічка). Програма повинна знайти індекси всіх входжень стрічки "needle" в стрічці "haystack" та повернути цей індекс, використовуючи  метод Кнутта-Морріса-Прата для пошуку підстрічки у стрічці
min_len_communication_wells - Лабораторна 9  Варіант 2 Рівень 2
        Компанія ІоТ Телеком надає послуги інтернету своїм споживачам. Вона володіє мережею телекомунікаційних колодязів, між якими прокладені кабелі зв'язку. Для роботи під час блекаутів компанія хоче прокласти резервні лінії зв'язку між колодязями. Оскільки ціна на оптоволоконний кабель є високою, компанія хоче провести кабелі лише таким чином, щоб витратити мінімальну довжину кабелю і при цьому провести оптоволоконний кабель до кожного колодязя

        Вхідні дані:
        
        файл communication_wells.csv, який містить пари колодязів та відстань між ними у форматі: К1, K2, 2000. цей запис означає, що між колодязями К1 та K2 відстань становить 2000 метрів
        Вихідні дані:
        
        Мінімальна довжина оптоволоконного кабелю, який потрібно прокласти між колодязями, або -1 - якщо існують колодязі, які не зв'язані з іншими.